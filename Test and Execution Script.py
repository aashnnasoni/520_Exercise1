# -*- coding: utf-8 -*-
"""520.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ih2_bRql5uul_Dzbz8MVnRNTT2bBwXJk
"""

!huggingface-cli login

!git clone https://huggingface.co/datasets/codeparrot/apps /content/drive/MyDrive/CS520

import pandas as pd
from datasets import load_dataset
base_path = "/content/drive/MyDrive/CS520"
# Load from local JSONL files
dataset = load_dataset(
    "json",
    data_files={
        "train": base_path + "/train.jsonl",
        "test": base_path + "/test.jsonl"
    }
)

# Access one sample
sample = dataset["train"][0]


df = pd.DataFrame(dataset["train"][10:20])
print(df.head())

# import json
# sample["solutions"] = json.loads(sample["solutions"])
# sample["input_output"] = json.loads(sample["input_output"])
# print(sample)

import pandas as pd
df = pd.DataFrame(dataset["train"][10:20])
print(df.head())

import json

samples = dataset["test"][10:20]
test_10_examples = base_path + "/test_10_examples.json"

# Save to JSON (pretty formatted)
with open(test_10_examples, "w") as f:
    json.dump(samples, f, indent=2)

import json
import subprocess
import tempfile
import os
import math


def run_code_with_input(code_str, test_input):
    """Executes the solution code with provided input and returns stdout."""
    with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
        f.write(code_str)
        code_path = f.name

    try:
        result = subprocess.run(
            ["python3", code_path],
            input=test_input,
            capture_output=True,
            text=True,
            timeout=5
        )
        return result.stdout.strip()
    except subprocess.TimeoutExpired:
        return "TIMEOUT"
    except Exception as e:
        return f"ERROR: {e}"
    finally:
        try:
            os.remove(code_path)
        except Exception:
            pass


def evaluate_solution(code_str, inputs, outputs):
    """Tests a single solution on all test cases."""
    total = len(inputs)
    passed = 0

    print(f"\nEvaluating solution...\n")

    for i, (inp, expected) in enumerate(zip(inputs, outputs), start=1):
        predicted = run_code_with_input(code_str, inp).strip()
        expected = expected.strip()

        if predicted == expected:
            result = "✅ Passed"
            passed += 1
        else:
            result = "❌ Failed"
            print(f"--- Test {i} ---")
            print(f"Input: {repr(inp)}")
            print(f"Expected: {repr(expected)}")
            print(f"Got: {repr(predicted)}")

        print(f"Test {i}: {result}")

    print(f"\nSummary: {passed}/{total} test cases passed.\n")
    return passed == total


def pass_at_k(n, c, k):
    """Computes pass@k according to OpenAI HumanEval definition."""
    if c == 0:
        return 0.0
    if n - c < k:
        return 1.0
    return 1 - math.comb(n - c, k) / math.comb(n, k)


def test_multiple_solutions(solution_codes, input_output_json):
    """Runs multiple solution codes on the same dataset and computes pass@k."""
    data = json.loads(input_output_json)
    inputs = data["inputs"]
    outputs = data["outputs"]

    n = len(solution_codes)
    results = []

    print(f"Evaluating {n} generated solutions...\n")

    for i, code in enumerate(solution_codes, start=1):
        print(f"========== Solution {i} ==========")
        passed_all = evaluate_solution(code, inputs, outputs)
        results.append(passed_all)
        print(f"Solution {i}: {'✅ Passed all tests' if passed_all else '❌ Failed some tests'}")

    c = sum(results)
    print(f"\nTotal passing solutions: {c}/{n}")

    pass1 = round(pass_at_k(n, c, 1), 4)
    pass2 = round(pass_at_k(n, c, 2), 4)

    print("\n=== pass@k Results ===")
    print(f"pass@1: {pass1}")
    print(f"pass@2: {pass2}")

    return {"pass@1": pass1, "pass@2": pass2, "passed": c, "total": n}


if __name__ == "__main__":
    solution_codes = [
        """def solve_game(s):
    n = len(s)

    # Precompute minimum character from each position to the end
    min_suffix = [''] * (n + 1)
    min_suffix[n] = chr(ord('z') + 1)  # Sentinel value larger than any letter

    for i in range(n - 1, -1, -1):
        min_suffix[i] = min(s[i], min_suffix[i + 1])

    t = []
    u = []
    pos = 0

    while pos < n or t:
        # Pop from t to u if:
        # 1. t is not empty AND
        # 2. Either s is exhausted OR top of t <= all remaining chars in s
        while t and (pos >= n or t[-1] <= min_suffix[pos]):
            u.append(t.pop())

        # Push from s to t if s is not exhausted
        if pos < n:
            t.append(s[pos])
            pos += 1

    return ''.join(u)

# Read input
s = input().strip()

# Solve and print result
result = solve_game(s)
print(result)


""",
        """def solve_game(s):
    n = len(s)

    # Precompute minimum character from each position to the end
    min_suffix = [''] * (n + 1)
    min_suffix[n] = chr(ord('z') + 1)  # Sentinel value larger than any letter

    for i in range(n - 1, -1, -1):
        min_suffix[i] = min(s[i], min_suffix[i + 1])

    t = []
    u = []
    pos = 0

    while pos < n or t:
        if t:
            # We can pop from t to u
            # Should we pop now or wait?
            # Pop if: t's top <= all remaining characters in s
            if pos >= n or t[-1] <= min_suffix[pos]:
                u.append(t.pop())
            else:
                # Push from s to t
                t.append(s[pos])
                pos += 1
        else:
            # Must push from s to t
            t.append(s[pos])
            pos += 1

    return ''.join(u)

# Read input
s = input().strip()

# Solve and print result
result = solve_game(s)
print(result)
"""
    ]

    with open("/content/drive/MyDrive/CS520/test_10_examples.json", "r", encoding="utf-8") as f:
        problem_data = json.load(f)

    input_output_json = problem_data["input_output"][8]

    test_multiple_solutions(solution_codes, input_output_json)